{"version":3,"file":"mesh-simplifier.min.js","sources":["../src/math/Vector3.ts","../src/MeshSimplifiers/FastQuadric/structs/Triangle.ts","../src/math/SymmetricMatrix.ts","../src/MeshSimplifiers/FastQuadric/structs/Vertex.ts","../src/MeshSimplifiers/FastQuadric/structs/Ref.ts","../src/math/Face3.ts","../src/util/Timer.ts","../src/MeshSimplifiers/FastQuadric/FastQuadric.ts","../src/Geometries/ThreeGeometry.ts","../src/consts.ts","../src/Adapters/ThreeAdapter.ts","../src/index.umd.ts"],"sourcesContent":["/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nclass Vector3 {\n  static addVectors(v1: Vector3, v2: Vector3) {\n    return new Vector3().copy(v1).add(v2);\n  }\n\n  static subVectors(v1: Vector3, v2: Vector3) {\n    return new Vector3().copy(v1).sub(v2);\n  }\n\n  public x: number;\n  public y: number;\n  public z: number;\n\n  constructor(v0: number = 0, v1: number = 0, v2: number = 0) {\n    this.x = v0;\n    this.y = v1;\n    this.z = v2;\n  }\n\n  public copy(other: Vector3) {\n    this.x = other.x;\n    this.y = other.y;\n    this.z = other.z;\n    return this;\n  }\n\n  public add(other: Vector3) {\n    this.x += other.x;\n    this.y += other.y;\n    this.z += other.z;\n    return this;\n  }\n\n  public sub(other: Vector3) {\n    this.x -= other.x;\n    this.y -= other.y;\n    this.z -= other.z;\n    return this;\n  }\n\n  public dot(other: Vector3): number {\n    const { x: x1, y: y1, z: z1 } = this;\n    const { x: x2, y: y2, z: z2 } = other;\n\n    return x1 * x2 + y1 * y2 + z1 * z2;\n  }\n\n  public cross(other: Vector3): this {\n    const { x: x1, y: y1, z: z1 } = this;\n    const { x: x2, y: y2, z: z2 } = other;\n\n    this.x = y1 * z2 - z1 * y2;\n    this.y = z1 * x2 - x1 * z2;\n    this.z = x1 * y2 - y1 * x2;\n    return this;\n  }\n\n  public normalize(): this {\n    const length = this.length();\n\n    if (length > 0) {\n      const invLength = 1 / length;\n      this.x *= invLength;\n      this.y *= invLength;\n      this.z *= invLength;\n    }\n\n    return this;\n  }\n\n  public length(): number {\n    const { x, y, z } = this;\n    return Math.sqrt(x * x + y * y + z * z);\n  }\n\n  public scaleSclar(factor: number): this {\n    this.x *= factor;\n    this.y *= factor;\n    this.z *= factor;\n\n    return this;\n  }\n}\n\nexport default Vector3;\n","/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Vector3 from \"~/math/Vector3\";\n\nclass Triangle {\n  public originalIndex: number;\n  public v: [number, number, number];\n  public err: [number, number, number, number];\n  public deleted: boolean;\n  public dirty: boolean;\n  public n: Vector3;\n\n  constructor(idx: number) {\n    this.originalIndex = idx;\n    this.v = [0, 0, 0];\n    this.err = [0, 0, 0, 0];\n    this.deleted = false;\n    this.dirty = false;\n    this.n = new Vector3();\n  }\n}\n\nexport default Triangle;\n","/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\n// Original code from\n// https://github.com/sp4cerat/Fast-Quadric-Mesh-Simplification/blob/master/src.gl/Simplify.h\n\nclass SymmetricMatrix {\n  static makePlane(a: number, b: number, c: number, d: number): SymmetricMatrix {\n    return new SymmetricMatrix(\n      a * a, a * b, a * c, a * d,\n             b * b, b * c, b * d,\n                    c * c, c * d,\n                           d * d,\n    );\n  }\n\n  public m: number[];\n\n  constructor(\n    m11: number = 0, m12: number = 0, m13: number = 0, m14: number = 0,\n                     m22: number = 0, m23: number = 0, m24: number = 0,\n                                      m33: number = 0, m34: number = 0,\n                                                       m44: number = 0,\n  ) {\n    this.m = new Array(10);\n    this.set(m11, m12, m13, m14, m22, m23, m24, m33, m34, m44);\n  }\n\n  public copy(other: SymmetricMatrix): this {\n    const m = other.m;\n    this.m = m.concat();\n    return this;\n  }\n\n  public set(\n    m11: number, m12: number, m13: number, m14: number,\n                 m22: number, m23: number, m24: number,\n                              m33: number, m34: number,\n                                           m44: number,\n  ) {\n    const m = this.m;\n    m[0] = m11; m[1] = m12; m[2] = m13; m[3] = m14;\n                m[4] = m22; m[5] = m23; m[6] = m24;\n                            m[7] = m33; m[8] = m34;\n                                        m[9] = m44;\n  }\n\n  public det(\n    a11: number, a12: number, a13: number,\n    a21: number, a22: number, a23: number,\n    a31: number, a32: number, a33: number,\n  ): number {\n    const m = this.m;\n    const det = m[a11] * m[a22] * m[a33]\n      + m[a13] * m[a21] * m[a32]\n      + m[a12] * m[a23] * m[a31]\n      - m[a13] * m[a22] * m[a31]\n      - m[a11] * m[a23] * m[a32]\n      - m[a12] * m[a21] * m[a33];\n    return det;\n  }\n\n  public add(other: SymmetricMatrix): this {\n    const m = this.m;\n    const n = other.m;\n    this.set(\n      m[0] + n[0], m[1] + n[1], m[2] + n[2], m[3] + n[3],\n                   m[4] + n[4], m[5] + n[5], m[6] + n[6],\n                                m[7] + n[7], m[8] + n[8],\n                                             m[9] + n[9],\n    );\n\n    return this;\n  }\n}\n\nexport default SymmetricMatrix;\n","/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Vector3 from \"~/math/Vector3\";\nimport SymmetricMatrix from \"~/math/SymmetricMatrix\";\n\nclass Vertex {\n  public originalIndex: number;\n  public p: Vector3;\n  public tstart: number;\n  public tcount: number;\n  public q: SymmetricMatrix;\n  public border: boolean;\n\n  constructor(idx: number) {\n    this.originalIndex = idx;\n    this.p = new Vector3();\n    this.tstart = 0;\n    this.tcount = 0;\n    this.q = new SymmetricMatrix();\n    this.border = false;\n  }\n}\n\nexport default Vertex;\n","/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nclass Ref {\n  public tid: number;\n  public tvertex: number;\n\n  constructor() {\n    this.tid = 0;\n    this.tvertex = 0;\n  }\n}\n\nexport default Ref;\n","/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Vector3 from \"./Vector3\";\n\nclass Face3 {\n  public index: number;\n  public normal: Vector3;\n\n  constructor(\n    public a: number,\n    public b: number,\n    public c: number\n  ) {}\n}\n\nexport default Face3;\n","/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nclass Timer {\n  private _diff: number = 0;\n  private _startTime: number | [number, number] | null = null;\n\n  /**\n   * Time diff in miliseconds\n   */\n  public get diff() { return this._diff; }\n\n  public start(): void {\n    if (typeof process !== \"undefined\" && process.hrtime) {\n      // Use high resolution timer in Node\n      this._startTime = process.hrtime();\n    } else {\n      this._startTime = Date.now();\n    }\n  }\n\n  public end(): void {\n    // Not started\n    if (this._startTime == null) return;\n\n    if (typeof process !== \"undefined\" && process.hrtime) {\n      // Use high resolution timer in Node\n      const diff = process.hrtime(this._startTime as [number, number]);\n      const diffInMiliSeconds = 1000 * (diff[0] + diff[1] * 1e-9); // diff[1] is in nanoseconds\n\n      this._diff = diffInMiliSeconds;\n    } else {\n      this._diff = Date.now() - (this._startTime as number);\n    }\n\n    this._startTime = null;\n  }\n}\n\nexport default Timer;\n","/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n * Original code: https://github.com/sp4cerat/Fast-Quadric-Mesh-Simplification\n * License: MIT\n */\n\nimport MeshSimplifier from \"../MeshSimplifier\";\nimport Triangle from \"./structs/Triangle\";\nimport Vertex from \"./structs/Vertex\";\nimport Ref from \"./structs/Ref\";\nimport Vector3 from \"~/math/Vector3\";\nimport Face3 from \"~/math/Face3\";\nimport SymmetricMatrix from \"~/math/SymmetricMatrix\";\nimport Adapter from \"~/Adapters/Adapter\";\nimport Geometry from \"~/Geometries/Geometry\";\nimport Timer from \"~/util/Timer\";\n\nclass FastQuadric implements MeshSimplifier {\n  /* Options */\n  public targetPercentage: number;\n  public aggressiveness: number;\n\n  private _triangles: Triangle[];\n  private _vertices: Vertex[];\n  private _refs: Ref[];\n  private _timer: Timer;\n\n  public get timeConsumed() { return this._timer.diff; }\n\n  constructor({\n    targetPercentage = 0.5,\n    aggressiveness = 7\n  } = {}) {\n    this._triangles = [];\n    this._vertices = [];\n    this._refs = [];\n    this.targetPercentage = targetPercentage;\n    this.aggressiveness = aggressiveness;\n    this._timer = new Timer();\n  }\n\n  public simplify(target: Adapter | Geometry): this {\n    const timer = this._timer;\n    timer.start();\n\n    if ((target as Adapter).geometries) {\n      (target as Adapter).geometries.forEach(geometry => {\n        this._process(geometry);\n      });\n    } else {\n      this._process(target as Geometry);\n    }\n\n    timer.end();\n\n    return this;\n  }\n\n  private _process(geometry: Geometry) {\n    this._getData(geometry);\n\n    const triangles = this._triangles;\n    const vertices = this._vertices;\n    const refs = this._refs;\n    const targetPercentage = this.targetPercentage;\n    const aggressiveness = this.aggressiveness;\n\n    const targetCount = this._triangles.length * targetPercentage;\n\n    triangles.forEach(triangle => triangle.deleted = false);\n\n    let deletedTriangles: number = 0;\n    const deleted0: boolean[] = [];\n    const deleted1: boolean[] = [];\n    const triangleCount = triangles.length;\n\n    for (let iteration = 0; iteration < 100; iteration++) {\n      // Break when target number of triangles reached\n      if (triangleCount - deletedTriangles <= targetCount) break;\n\n      // Update mesh once in a while\n\t\t\tif (iteration % 5 === 0) {\n\t\t\t\tthis._updateMesh(iteration);\n      }\n\n      // Clear dirty flag\n      triangles.forEach(triangle => triangle.dirty = false);\n\n      //\n\t\t\t// All triangles with edges below the threshold will be removed\n\t\t\t//\n\t\t\t// The following numbers works well for most models.\n\t\t\t// If it does not, try to adjust the 3 parameters\n      //\n      const threshold = 0.000000001 * Math.pow(iteration + 3, aggressiveness);\n\n      for (let i = triangles.length - 1; i >= 0; i--) {\n        const t = triangles[i];\n        if (t.err[3] > threshold || t.deleted || t.dirty) continue;\n\n        for (let j = 0; j < 3; j++) {\n          if (t.err[j] < threshold) {\n            const i0 = t.v[j];\n            const i1 = t.v[(j + 1) % 3];\n\n            const v0 = vertices[i0];\n            const v1 = vertices[i1];\n\n            // Border check\n            if (v0.border || v1.border) continue;\n\n            // Compute vertex to collapse to\n            const p = new Vector3();\n            this._calculateError(i0, i1, p);\n\n            deleted0.splice(0); // normals temporarily\n            deleted1.splice(0); // normals temporarily\n\n            // Don't remove if flipped\n            if (this._flipped(p, i1, v0, deleted0)) continue;\n            if (this._flipped(p, i0, v1, deleted1)) continue;\n\n            // Not flipped, so remove edge\n            v0.p = p;\n            v0.q.add(v1.q);\n\n            const tstart = refs.length;\n\n            deletedTriangles += this._updateTriangles(i0, v0, deleted0);\n            deletedTriangles += this._updateTriangles(i0, v1, deleted1);\n\n            const tcount = refs.length - tstart;\n\n            v0.tstart = tstart;\n            v0.tcount = tcount;\n            break;\n          }\n        }\n\n        // Done?\n        if (triangleCount - deletedTriangles <= targetCount) break;\n      }\n    }\n\n    this._compactMesh();\n\n    this._setData(geometry);\n  }\n\n  private _getData(geometry: Geometry) {\n    const data = geometry.prepare();\n\n    this._vertices = data.vertices.map((v, idx) => {\n      const vertex = new Vertex(idx);\n      vertex.p.copy(v);\n      return vertex;\n    });\n\n    this._triangles = data.faces.map((f, idx) => {\n      const triangle = new Triangle(idx);\n      triangle.v = [f.a, f.b, f.c];\n      return triangle;\n    });\n\n    this._refs = [];\n  }\n\n  private _setData(geometry: Geometry) {\n    const triangles = this._triangles;\n\n    const vertices = this._vertices.map(vertex => vertex.p);\n    const faces = triangles.map(triangle => {\n      const v = triangle.v;\n      return new Face3(v[0], v[1], v[2]);\n    });\n\n    const unculledVertices = this._vertices.map(v => v.originalIndex);\n    const unculledFaces = this._triangles.map(f => f.originalIndex);\n\n    geometry.update({\n      vertices,\n      faces,\n      unculledVertices,\n      unculledFaces,\n    });\n  }\n\n  private _flipped(p: Vector3, i: number, v: Vertex, deleted: boolean[]): boolean {\n    const triangles = this._triangles;\n    const vertices = this._vertices;\n    const refs = this._refs;\n\n    for (let k = 0; k < v.tcount; k++) {\n      const ref = refs[v.tstart + k];\n      const t = triangles[ref.tid];\n      if (t.deleted) continue;\n\n      const s = ref.tvertex;\n      const id1 = t.v[(s + 1) % 3];\n      const id2 = t.v[(s + 2) % 3];\n\n      if (id1 === i || id2 === i) {\n        deleted[k] = true;\n        continue;\n      }\n\n      const d1 = Vector3.subVectors(vertices[id1].p, p);\n      const d2 = Vector3.subVectors(vertices[id2].p, p);\n      d1.normalize();\n      d2.normalize();\n\n      if (Math.abs(d1.dot(d2)) > 0.999) return true;\n\n      const n = new Vector3().copy(d1).cross(d2);\n      n.normalize();\n      deleted[k] = false;\n      if (n.dot(t.n) < 0.2) return true;\n    }\n    return false;\n  }\n\n  private _updateTriangles(i: number, v: Vertex, deleted: boolean[]): number {\n    const triangles = this._triangles;\n    const refs = this._refs;\n    const p = new Vector3();\n\n    let deletedCount = 0;\n    for (let k = 0; k < v.tcount; k++) {\n      const r = refs[v.tstart + k];\n      const t = triangles[r.tid];\n\n      if (t.deleted) continue;\n      if (deleted[k]) {\n        t.deleted = true;\n        deletedCount++;\n        continue;\n      }\n\n      t.v[r.tvertex] = i;\n      t.dirty = true;\n      t.err[0] = this._calculateError(t.v[0], t.v[1], p);\n      t.err[1] = this._calculateError(t.v[1], t.v[2], p);\n      t.err[2] = this._calculateError(t.v[2], t.v[0], p);\n      t.err[3] = Math.min(t.err[0], t.err[1], t.err[2]);\n      refs.push(r);\n    }\n\n    return deletedCount;\n  }\n\n  private _updateMesh(iteration: number) {\n    const vertices = this._vertices;\n    const refs = this._refs;\n\n\t\tif (iteration > 0) {\n      // compact triangles\n      this._triangles = this._triangles.filter(triangle => !triangle.deleted);\n\t\t} else {\n      //\n      // Init Quadrics by Plane & Edge Errors\n      //\n      // required at the beginning ( iteration == 0 )\n      // recomputing during the simplification is not required,\n      // but mostly improves the result for closed meshes\n      //\n      vertices.forEach(vertex => vertex.q = new SymmetricMatrix());\n\n      this._triangles.forEach(t => {\n        const p = t.v.map(v => vertices[v].p);\n        const n = Vector3.subVectors(p[1], p[0])\n          .cross(Vector3.subVectors(p[2], p[0]))\n          .normalize();\n\n        t.n = n;\n        const tmp = SymmetricMatrix.makePlane(n.x, n.y, n.z, -n.dot(p[0]));\n\n        t.v.forEach(v => vertices[v].q.add(tmp));\n      });\n\n      this._triangles.forEach(t => {\n        const p = new Vector3();\n        t.v.forEach((v, i) => {\n          t.err[i] = this._calculateError(v, t.v[(i + 1) % 3], p);\n        });\n      });\n    }\n\n    // Init Reference ID list\n    vertices.forEach(vertex => {\n      vertex.tstart = 0;\n      vertex.tcount = 0;\n    });\n\n    const triangles = this._triangles;\n    triangles.forEach(triangle => {\n      triangle.v.forEach(v => vertices[v].tcount++);\n    });\n\n    let tstart = 0;\n    vertices.forEach(v => {\n      v.tstart = tstart;\n      tstart += v.tcount;\n      v.tcount = 0;\n    });\n\n    // Write References\n    for (let i = refs.length; i < triangles.length * 3; i++) {\n\t\t\trefs[i] = new Ref();\n\t\t}\n\n    triangles.forEach((t, i) => {\n      for (let j = 0; j < 3; j++) {\n        const v = vertices[t.v[j]];\n        refs[v.tstart + v.tcount].tid = i;\n        refs[v.tstart + v.tcount].tvertex = j;\n        v.tcount++;\n      };\n    });\n\n\t\t// Identify boundary : vertices[].border=0,1\n\t\tif (iteration === 0) {\n      vertices.forEach(vertex => vertex.border = false);\n      vertices.forEach(v => {\n        // clear\n        const vcount: number[] = [];\n        const vids: number[] = [];\n\n        for (let i = 0; i < v.tcount; i++) {\n          const k = refs[v.tstart + i].tid;\n          const t = triangles[k];\n\n          for (let j = 0; j < 3; j++) {\n            const id = t.v[j];\n            let ofs = 0;\n\n            while (ofs < vcount.length) {\n              if (vids[ofs] === id) break;\n              ofs++;\n            }\n\n            if (ofs === vcount.length) {\n              vcount.push(1);\n              vids.push(id);\n            } else {\n              vcount[ofs]++;\n            }\n          };\n        }\n\n        for (let j = 0; j < vcount.length; j++) {\n          if (vcount[j] === 1) {\n            vertices[vids[j]].border = true;\n          }\n        };\n      });\n\t\t}\n  }\n\n  // Error for one edge\n  private _calculateError(idV1: number, idV2: number, result: Vector3) {\n    // Compute interpolated vertex\n    const vertices = this._vertices;\n    const v1 = vertices[idV1];\n    const v2 = vertices[idV2];\n    const q = new SymmetricMatrix().copy(v1.q).add(v2.q);\n    const border = v1.border && v2.border;\n    const det = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);\n\n    let error: number = 0;\n\n    if (det !== 0 && !border) {\n      // q_delta is invertible\n      result.x = -1 / det * (q.det(1, 2, 3, 4, 5, 6, 5, 7, 8)); // vx = A41/det(q_delta)\n      result.y =  1 / det * (q.det(0, 2, 3, 1, 5, 6, 2, 7, 8)); // vy = A42/det(q_delta)\n      result.z = -1 / det * (q.det(0, 1, 3, 1, 4, 6, 2, 5, 8)); // vz = A43/det(q_delta)\n      error = this._vertexError(q, result);\n    } else {\n      const p1 = v1.p;\n      const p2 = v2.p;\n      const p3 = new Vector3(\n        (p1.x + p2.x) * 0.5,\n        (p1.y + p2.y) * 0.5,\n        (p1.z + p2.z) * 0.5,\n      );\n\n      const error1 = this._vertexError(q, p1);\n      const error2 = this._vertexError(q, p2);\n      const error3 = this._vertexError(q, p3);\n      error = Math.min(error1, error2, error3);\n\n      if (error1 === error) result.copy(p1);\n      if (error2 === error) result.copy(p2);\n      if (error3 === error) result.copy(p3);\n    }\n\n    return error;\n  }\n\n  private _vertexError(q: SymmetricMatrix, v: Vector3): number {\n    const {x, y, z} = v;\n    const m = q.m;\n\n    const err = m[0] * x * x\n      + 2 * m[1] * x * y\n      + 2 * m[2] * x * z\n      + 2 * m[3] * x\n      +     m[4] * y * y\n      + 2 * m[5] * y * z\n      + 2 * m[6] * y\n      +     m[7] * z * z\n      + 2 * m[8] * z\n      +     m[9];\n\n    return err;\n  }\n\n  private _compactMesh() {\n    this._triangles = this._triangles.filter(t => !t.deleted);\n\n    const triangles = this._triangles;\n    const vertices = this._vertices;\n\n    vertices.forEach(vertex => vertex.tcount = 0);\n    triangles.forEach(triangle => {\n      triangle.v.forEach(v => {\n        vertices[v].tcount = 1;\n      });\n    });\n\n    let dst = 0;\n    vertices.forEach(vertex => {\n      if (vertex.tcount > 0) {\n        vertex.tstart = dst;\n        vertices[dst].originalIndex = vertex.originalIndex;\n        vertices[dst].p = vertex.p;\n        dst++;\n      }\n    });\n\n    triangles.forEach(t => {\n      t.v.forEach((v, i) => {\n        t.v[i] = vertices[v].tstart;\n      });\n    });\n\n    vertices.splice(dst); // resize\n  }\n}\n\nexport default FastQuadric;\n","/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport * as THREE from \"three\";\nimport Geometry from \"./Geometry\";\nimport Vector3 from \"~/math/Vector3\";\nimport Face3 from \"~/math/Face3\";\n\n// TODO: Support line geometry\n\n/**\n * Adapter class for three.js geometry\n * @example\n * import * as THREE from \"three\";\n * import { FastQuadric, ThreeGeometry } from \"mesh-simplifier\";\n *\n * const geometry = new THREE.TorusKnotGeometry(10);\n * const adaptedGeometry = new ThreeGeometry(geometry);\n *\n * const simplifier = new FastQuadric();\n * simplifier.simplify(adaptedGeometry);\n *\n * // Now do whatever you want with simplified geometry\n * const material = new THREE.MeshBasicMaterial();\n * const mesh = new THREE.Mesh(adaptedGeometry.simplified, material);\n */\nclass ThreeGeometry implements Geometry {\n  public originalGeometry: THREE.Geometry | THREE.BufferGeometry;\n  private _processingGeometry: THREE.Geometry;\n  private _isBufferGeometry: boolean;\n\n  constructor(geometry: THREE.Geometry | THREE.BufferGeometry) {\n    this._isBufferGeometry = (geometry as THREE.BufferGeometry).isBufferGeometry;\n    this.originalGeometry = geometry;\n\n    if (this._isBufferGeometry) {\n      this._processingGeometry = new THREE.Geometry().fromBufferGeometry(geometry as THREE.BufferGeometry);\n    } else {\n      this._processingGeometry = this.originalGeometry as THREE.Geometry;\n    }\n  }\n\n  public prepare() {\n    const geometry = this._processingGeometry;\n    geometry.mergeVertices();\n\n    return {\n      vertices: geometry.vertices.map(vec => new Vector3(vec.x, vec.y, vec.z)),\n      faces: geometry.faces.map(face => new Face3(face.a, face.b, face.c)),\n    }\n  }\n\n  public update(datas: {\n    vertices: Vector3[],\n    faces: Face3[],\n    unculledVertices: number[],\n    unculledFaces: number[],\n  }): this {\n    const { vertices, faces, unculledVertices, unculledFaces } = datas\n\n    const geometry = this._processingGeometry;\n    const faceVertexUVs = geometry.faceVertexUvs;\n    const hasUV = faceVertexUVs[0] && faceVertexUVs[0].length > 0;\n    const hasUV2 = faceVertexUVs[1] && faceVertexUVs[1].length > 0;\n\n    geometry.vertices = vertices.map(vertex => new THREE.Vector3(vertex.x, vertex.y, vertex.z));\n    geometry.faces = faces.map(face => new THREE.Face3(face.a, face.b, face.c));\n\n    if (hasUV) {\n      geometry.faceVertexUvs[0] = unculledFaces.map(faceIdx => {\n        return geometry.faceVertexUvs[0][faceIdx];\n      });\n    }\n    if (hasUV2) {\n      geometry.faceVertexUvs[1] = unculledFaces.map(faceIdx => {\n        return geometry.faceVertexUvs[1][faceIdx];\n      });\n    }\n\n    geometry.computeFaceNormals();\n\n    if (this._isBufferGeometry) {\n      const origGeo = this.originalGeometry as THREE.BufferGeometry;\n\n      const bufferGeo = new THREE.BufferGeometry().fromGeometry(geometry);\n      const hasColor = origGeo.attributes.color && origGeo.attributes.color.count > 0;\n      const hasTangent = origGeo.attributes.tangent && origGeo.attributes.tangent.count > 0;\n\n      if (!hasColor) bufferGeo.deleteAttribute(\"color\");\n      if (hasTangent && hasUV) {\n        const tangents = new Float32Array(faces.length * 12);\n\n        faces.forEach((face, faceIdx) => {\n          const faceVertices = [face.a, face.b, face.c].map(idx => geometry.vertices[idx]);\n          const faceUVs = faceVertexUVs[0][faceIdx];\n\n          const dPos0 = new THREE.Vector3().subVectors(faceVertices[1], faceVertices[0]);\n          const dPos1 = new THREE.Vector3().subVectors(faceVertices[2], faceVertices[0]);\n\n          const dUV0 = new THREE.Vector2().subVectors(faceUVs[1], faceUVs[0]);\n          const dUV1 = new THREE.Vector2().subVectors(faceUVs[2], faceUVs[0]);\n\n          const r = 1 / (dUV0.x * dUV1.y - dUV0.y * dUV1.x);\n          const tangent = dPos0.multiplyScalar(dUV1.y).sub(dPos1.multiplyScalar(dUV0.y)).multiplyScalar(r).normalize();\n\n          const faceOffset = faceIdx * 12;\n\n          [0, 1, 2].forEach(vIdx => {\n            const vertexOffset = faceOffset + vIdx * 4;\n            tangents[vertexOffset + 0] = tangent.x;\n            tangents[vertexOffset + 1] = tangent.y;\n            tangents[vertexOffset + 2] = tangent.z;\n            tangents[vertexOffset + 3] = 1;\n          });\n        });\n\n        bufferGeo.setAttribute(\"tangent\", new THREE.BufferAttribute(tangents, 4));\n      }\n\n      origGeo.copy(bufferGeo);\n    } else {\n      geometry.verticesNeedUpdate = true;\n      geometry.elementsNeedUpdate = true;\n      geometry.uvsNeedUpdate = true;\n    }\n\n    return this;\n  }\n}\n\nexport default ThreeGeometry;\n","export const THREE_STANDARD_MAPS = [\n  \"alphaMap\",\n  \"aoMap\",\n  \"bumpMap\",\n  \"displacementMap\",\n  \"emissiveMap\",\n  \"envMap\",\n  \"lightMap\",\n  \"map\",\n  \"metalnessMap\",\n  \"normalMap\",\n  // \"roughnessMap\", excluded on purpose\n];\n","/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport * as THREE from \"three\";\nimport Adapter from \"./Adapter\";\nimport ThreeGeometry from \"~/Geometries/ThreeGeometry\";\nimport { THREE_STANDARD_MAPS } from \"~/consts\";\n\nclass ThreeAdapter<OBJ extends THREE.Object3D> implements Adapter {\n  public object: OBJ;\n\n  constructor(original: OBJ, clone: boolean = false) {\n    this.object = clone\n      ? original.clone()\n      : original;\n\n    if (clone) {\n      this._cloneMeshes(original);\n    }\n  }\n\n  public get geometries() {\n    const geometries: ThreeGeometry[] = [];\n    this.object.traverse(obj => {\n      if ((obj as THREE.Mesh).isMesh) {\n        const mesh = obj as THREE.Mesh;\n        const threeGeometry = new ThreeGeometry(mesh.geometry);\n\n        geometries.push(threeGeometry);\n      }\n    });\n\n    return geometries;\n  }\n\n  private _cloneMeshes(original: OBJ) {\n    const origMeshes: THREE.Mesh[] = [];\n    const clonedMeshes: THREE.Mesh[] = [];\n\n    original.traverse(obj => {\n      if ((obj as THREE.Mesh).isMesh) origMeshes.push(obj as THREE.Mesh);\n    });\n    this.object.traverse(obj => {\n      if ((obj as THREE.Mesh).isMesh) clonedMeshes.push(obj as THREE.Mesh);\n    });\n\n    clonedMeshes.forEach((mesh, meshIdx) => {\n      const origMesh = origMeshes[meshIdx];\n\n      mesh.geometry = mesh.geometry.clone();\n      mesh.material = Array.isArray(mesh.material)\n        ? mesh.material.map(mat => this._cloneMaterial(mat))\n        : this._cloneMaterial(mesh.material);\n\n      if ((mesh as THREE.SkinnedMesh).isSkinnedMesh) {\n        this._skinnedMeshToMesh(\n          mesh as THREE.SkinnedMesh,\n          (origMesh as THREE.SkinnedMesh).skeleton\n        );\n      }\n    });\n  }\n\n  private _cloneMaterial(mat: THREE.Material) {\n    const clonedMat = mat.clone();\n\n    if (mat.type === \"MeshStandardMaterial\") {\n      const standardMat = mat as THREE.MeshStandardMaterial;\n      THREE_STANDARD_MAPS.forEach(mapName => {\n        if (standardMat[mapName] == null) return;\n\n        const prevMat = standardMat[mapName];\n        standardMat[mapName] = standardMat[mapName].clone();\n        standardMat[mapName].needsUpdate = true;\n\n        if (mapName === \"metalnessMap\" && prevMat === standardMat.roughnessMap) {\n          standardMat.roughnessMap = standardMat.metalnessMap;\n        }\n      });\n    } else {\n      for (const property in clonedMat) {\n        if (clonedMat[property] && clonedMat[property].isTexture) {\n          clonedMat[property] = clonedMat[property].clone();\n          clonedMat[property].needsUpdate = true;\n        }\n      }\n    }\n\n    clonedMat.needsUpdate = true;\n    return clonedMat;\n  }\n\n  private _skinnedMeshToMesh(skinnedMesh: THREE.SkinnedMesh, skeleton: THREE.Skeleton) {\n    const geometry = skinnedMesh.geometry as THREE.BufferGeometry;\n    const positions = geometry.attributes.position;\n    const skinIndicies = geometry.attributes.skinIndex;\n    const skinWeights = geometry.attributes.skinWeight;\n\n    skinnedMesh.updateMatrixWorld();\n    skeleton.update();\n\n    const boneMatricies = skeleton.boneMatrices;\n    const finalMatrix = new THREE.Matrix4();\n    for (let posIdx = 0; posIdx < positions.count; posIdx++) {\n      finalMatrix.identity();\n\n      const skinned = new THREE.Vector4();\n      skinned.set(0, 0, 0, 0);\n      const skinVertex = new THREE.Vector4();\n      skinVertex.set(\n        positions.getX(posIdx),\n        positions.getY(posIdx),\n        positions.getZ(posIdx),\n        1,\n      ).applyMatrix4(skinnedMesh.bindMatrix);\n\n      const weights = [\n        skinWeights.getX(posIdx),\n        skinWeights.getY(posIdx),\n        skinWeights.getZ(posIdx),\n        skinWeights.getW(posIdx),\n      ];\n\n      const indicies = [\n        skinIndicies.getX(posIdx),\n        skinIndicies.getY(posIdx),\n        skinIndicies.getZ(posIdx),\n        skinIndicies.getW(posIdx),\n      ];\n\n      weights.forEach((weight, index) => {\n        const boneMatrix = new THREE.Matrix4().fromArray(boneMatricies, indicies[index] * 16).multiplyScalar(weight);\n        skinned.add(skinVertex.clone().applyMatrix4(boneMatrix));\n      });\n\n      const transformed = skinned.applyMatrix4(skinnedMesh.bindMatrixInverse);\n\n      positions.setXYZ(posIdx, transformed.x, transformed.y, transformed.z);\n    }\n\n    const parent = skinnedMesh.parent!;\n    const mesh = new THREE.Mesh(skinnedMesh.geometry, skinnedMesh.material).copy(skinnedMesh);\n\n    (mesh.geometry as THREE.BufferGeometry).deleteAttribute(\"skinIndex\");\n    (mesh.geometry as THREE.BufferGeometry).deleteAttribute(\"skinWeight\");\n\n    parent.remove(skinnedMesh);\n    parent.add(mesh);\n  }\n}\n\nexport default ThreeAdapter;\n","/*\n * Copyright (c) 2020 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport * as Simplifiers from \"./MeshSimplifiers\";\nimport * as math from \"./math\";\nimport * as Geometries from \"./Geometries\";\nimport * as Adapters from \"./Adapters\";\n\nexport default {\n  ...Simplifiers,\n  ...math,\n  ...Geometries,\n  ...Adapters,\n}\n"],"names":["v0","v1","v2","x","y","z","Vector3","copy","add","sub","other","this","_a","x1","y1","z1","x2","y2","z2","invLength","length","Math","sqrt","factor","idx","originalIndex","v","err","deleted","dirty","n","m11","m12","m13","m14","m22","m23","m24","m33","m34","m44","m","Array","set","SymmetricMatrix","a","b","c","d","concat","a11","a12","a13","a21","a22","a23","a31","a32","a33","p","tstart","tcount","q","border","tid","tvertex","Object","_diff","process","hrtime","_startTime","Date","now","diff","diffInMiliSeconds","_b","_c","targetPercentage","_d","aggressiveness","_triangles","_vertices","_refs","_timer","Timer","target","timer","start","geometries","forEach","geometry","_this","_process","end","_getData","triangles","vertices","refs","targetCount","triangle","deletedTriangles","deleted0","deleted1","triangleCount","iteration","_updateMesh","threshold","pow","i","t","j","i0","i1","_calculateError","splice","_flipped","_updateTriangles","_compactMesh","_setData","data","prepare","map","vertex","Vertex","faces","f","Triangle","Face3","unculledVertices","unculledFaces","update","k","ref","s","id1","id2","d1","subVectors","d2","normalize","abs","dot","cross","deletedCount","r","min","push","filter","tmp","makePlane","Ref","vcount","vids","id","ofs","idV1","idV2","result","p1","p2","p3","error1","error2","error3","det","error","_vertexError","dst","_isBufferGeometry","isBufferGeometry","originalGeometry","_processingGeometry","THREE","fromBufferGeometry","mergeVertices","vec","face","datas","origGeo","bufferGeo","hasColor","hasTangent","tangents_1","faceVertexUVs","faceVertexUvs","hasUV","hasUV2","faceIdx","computeFaceNormals","fromGeometry","attributes","color","count","tangent","deleteAttribute","Float32Array","faceVertices","faceUVs","dPos0","dPos1","dUV0","dUV1","multiplyScalar","faceOffset","vIdx","vertexOffset","setAttribute","verticesNeedUpdate","elementsNeedUpdate","uvsNeedUpdate","THREE_STANDARD_MAPS","original","clone","object","_cloneMeshes","traverse","obj","threeGeometry","isMesh","ThreeGeometry","origMeshes","clonedMeshes","mesh","meshIdx","origMesh","material","isArray","mat","_cloneMaterial","isSkinnedMesh","_skinnedMeshToMesh","skeleton","clonedMat","type","standardMat_1","mapName","prevMat","needsUpdate","roughnessMap","metalnessMap","property","isTexture","skinnedMesh","positions","position","skinIndicies","skinIndex","skinWeights","skinWeight","updateMatrixWorld","boneMatricies","boneMatrices","finalMatrix","posIdx","identity","skinned","skinVertex","getX","getY","getZ","applyMatrix4","bindMatrix","weights","getW","indicies","weight","index","boneMatrix","fromArray","transformed","bindMatrixInverse","setXYZ","parent","remove","Simplifiers","math","Geometries","Adapters"],"mappings":"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"}